<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Giraffe - Barc's Backbone Framework</title>

    <!-- Stylesheets -->
    <link rel='stylesheet' type='text/css' href='_assets/tutdown.css' />

    <!-- Scripts -->
    <!--[if lt IE 9]><script type="text/javascript" src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>
<body>
    <div class="row">

      <!-- Sidebar -->
      <section id="sidebar" class="col sidebar">
        <h2><a href="index.html">Giraffe</a></h2>
<h2><a href="api.html">API</a></h2>
        <div id="nav"><div id="nav-background"></div><div class="nav-title"><a href="#View">View</a></div><ul><li><a href="#View-children"><span class="light-text">.</span>children</a></li><li><a href="#View-parent"><span class="light-text">.</span>parent</a></li><li><a href="#View-attachTo"><span class="light-text">.</span>attachTo</a></li><li><a href="#View-attach"><span class="light-text">.</span>attach</a></li><li><a href="#View-beforeRender"><span class="light-text">.</span>beforeRender</a></li><li><a href="#View-render"><span class="light-text">.</span>render</a></li><li><a href="#View-afterRender"><span class="light-text">.</span>afterRender</a></li><li><a href="#View-getHTML"><span class="light-text">.</span>getHTML</a></li><li><a href="#View-serialize"><span class="light-text">.</span>serialize</a></li><li><a href="#View-detach"><span class="light-text">.</span>detach</a></li><li><a href="#View-detachChildren"><span class="light-text">.</span>detachChildren</a></li><li><a href="#View-addChild"><span class="light-text">.</span>addChild</a></li><li><a href="#View-addChildren"><span class="light-text">.</span>addChildren</a></li><li><a href="#View-removeChild"><span class="light-text">.</span>removeChild</a></li><li><a href="#View-removeChildren"><span class="light-text">.</span>removeChildren</a></li><li><a href="#View-setParent"><span class="light-text">.</span>setParent</a></li><li><a href="#View-isAttached"><span class="light-text">.</span>isAttached</a></li><li><a href="#View-ui"><span class="light-text">.</span>ui</a></li><li><a href="#View-invoke"><span class="light-text">.</span>invoke</a></li><li><a href="#View-appEvents"><span class="light-text">.</span>appEvents</a></li><li><a href="#View-dispose"><span class="light-text">.</span>dispose</a></li><li><a href="#View-detachByEl"><span class="light-text">.</span>detachByEl</a></li><li><a href="#View-getClosestView"><span class="light-text">.</span>getClosestView</a></li><li><a href="#View-getByCid"><span class="light-text">.</span>getByCid</a></li><li><a href="#View-removeDocumentEvents"><span class="light-text">.</span>removeDocumentEvents</a></li><li><a href="#View-setDocumentEvents"><span class="light-text">.</span>setDocumentEvents</a></li><li><a href="#View-setTemplateStrategy"><span class="light-text">.</span>setTemplateStrategy</a></li></ul><div class="nav-title"><a href="#App">App</a></div><ul><li><a href="#App-addInitializer"><span class="light-text">.</span>addInitializer</a></li><li><a href="#App-start"><span class="light-text">.</span>start</a></li></ul><div class="nav-title"><a href="#Router">Router</a></div><ul><li><a href="#Router-triggers"><span class="light-text">.</span>triggers</a></li><li><a href="#Router-reload"><span class="light-text">.</span>reload</a></li><li><a href="#Router-cause"><span class="light-text">.</span>cause</a></li><li><a href="#Router-isCaused"><span class="light-text">.</span>isCaused</a></li><li><a href="#Router-getRoute"><span class="light-text">.</span>getRoute</a></li><li><a href="#Router-appEvents"><span class="light-text">.</span>appEvents</a></li><li><a href="#Router-dispose"><span class="light-text">.</span>dispose</a></li></ul><div class="nav-title"><a href="#Model">Model</a></div><ul><li><a href="#Model-appEvents"><span class="light-text">.</span>appEvents</a></li><li><a href="#Model-dispose"><span class="light-text">.</span>dispose</a></li></ul><div class="nav-title"><a href="#Collection">Collection</a></div><ul><li><a href="#Collection-appEvents"><span class="light-text">.</span>appEvents</a></li><li><a href="#Collection-dispose"><span class="light-text">.</span>dispose</a></li></ul><div class="nav-title"><a href="#dispose">dispose</a></div><ul></ul><div class="nav-title"><a href="#bindEvent">bindEvent</a></div><ul></ul><div class="nav-title"><a href="#unbindEvent">unbindEvent</a></div><ul></ul><div class="nav-title"><a href="#bindEventMap">bindEventMap</a></div><ul></ul><div class="nav-title"><a href="#unbindEventMap">unbindEventMap</a></div><ul></ul></div>
      </section>

      <!-- Main Body -->
      <article id="content" class="col content">
        <img id="logo" src="img/logo.png" />
        <div id="content"><section><h2 id="View">View<span class="caption">new Giraffe.View([options])</span></h2><p><strong>Giraffe.View</strong> is optimized for simplicity and flexibility. It provides lifecycle management for all <code>children</code>, which can be any object that implements a <code>dispose</code> method. The <code>attachTo</code> method automatically sets up parent-child relationships between views to allow nesting with no extra work, and any other object can have its lifecycle managed via <code>addChild</code>. When a view is disposed, it disposes of all of its <code>children</code>, allowing us to destroy anything from a single view to an entire application with a single method call. When a view renders, it first calls <code>detach</code> on all of its children, and when a view is detached, the default behavior is to dispose of that view. To overried this behavior and keep a view cached even when its parent renders, you can set the cached view's <code>options.disposeOnDetach</code> to <code>false</code>.</p>

<p>Views can move around the DOM safely and freely with the <code>attachTo</code> method, which accepts any selector, DOM element, or view, as well as an optional jQuery insertion method like <code>'prepend'</code>, <code>'after'</code>, or <code>'html'</code>. The default is <code>'append'</code>.</p>

<p>The <strong>Giraffe.View</strong> gets much of its smarts by way of the <code>data-view-cid</code> attribute attached to <code>view.$el</code>. This attribute allows us to find a view's parent when attached to a selector or DOM element and safely detach views when they would otherwise be clobbered. Currently, Giraffe has only one class that extends <strong>Giraffe.View</strong>, <strong>Giraffe.App</strong>, which encapsulates app-wide messenging and routing.</p><p>Similar to the <code>events</code> hash of <strong>Backbone.View</strong>, the <code>appEvents</code> hash maps events on <code>this.app</code> to methods on the view. App events can be triggered from routes or by any object in your application. If a <strong>Giraffe.App</strong> has been created, every view has a reference to the global <strong>Giraffe.app</strong> instance at <code>this.app</code>, and a specific app instance can be set by passing <code>options.app</code> to the view. The instance of <code>this.app</code> is used to bind <code>appEvents</code>, and these bindings are automatically cleaned up when a view is disposed. See <strong>Giraffe.App</strong> and <strong>Giraffe.Router</strong> for more.</p><h3 id="View-children">children<span class="caption">view.children</span></h3><p>When one view is attached to another, the child view is added to the parent's <code>children</code> array. When a view renders, it first calls <code>detach</code> on its <code>children</code>. By default, <code>dispose</code> is called on a view when it is detached if <code>options.disposeOnDetach</code> is <code>true</code>, which is the default setting. After a view renders, any child views with <code>options.disposeOnDetach</code> set to <code>false</code> will be in <code>children</code>, ready to be attached. When <code>dispose</code> is called on a view, it disposes of all of its <code>children</code>. Any object with a <code>dispose</code> method can be added to a view's <code>children</code> via <code>addChild</code> to take advantage of lifecycle management.</p><h3 id="View-parent">parent<span class="caption">view.parent</span></h3><p>Child views have a reference to their parent view.</p><h3 id="View-attachTo">attachTo<span class="caption">view.attachTo(el, [options])</span></h3><p>Attaches this view to <code>el</code>, which can be a selector, DOM element, or view. If <code>el</code> has a parent view, a parent-child relationship is set up. If the view has not yet been rendered when attached, <code>render</code> is called. This render behavior can be overridden through the options <code>forceRender</code> and <code>suppressRender</code>. Before a view renders, it calls <code>detach</code> on all of its <code>children</code>, and when a view is detached, it is also disposed, unless <code>options.disposeOnDetach</code> is set to false.</p><h3 id="View-attach">attach<span class="caption">view.attach(view, [options])</span></h3><p><code>attach</code> is an inverted way to call <code>attachTo</code>. Unlike <code>attachTo</code>, calling this function requires a parent view. It's here only for aesthetics.</p><h3 id="View-beforeRender">beforeRender<span class="caption">Implement this function in your views.</span></h3><p>This is an empty function for you to implement. Used in fewer situations than <code>afterRender</code>, but helpful in circumstances where the DOM has state that need to be preserved across renders. For example, if a view with a dropdown menu is rendering, you may want to save its open state in <code>beforeRender</code> and reapply it in <code>afterRender</code>.</p><h3 id="View-render">render<span class="caption">Do not override unless you know what you're doing!</span></h3><p>Giraffe implements <code>render</code> so it can do some helpful things, but you can still call it like you normally would. It consumes the method <code>getHTML</code>, a method your views should implement that returns a view's HTML as a string.</p><h3 id="View-afterRender">afterRender<span class="caption">Implement this function in your views.</span></h3><p>This is an empty function for you to implement. After a view renders, <code>afterRender</code> is called. Child views are normally attached to the DOM here. Views that are cached by setting <code>options.disposeOnDetach</code> to true will be in <code>view.children</code> in <code>afterRender</code>, but will not be attached to the parent's <code>$el</code>.</p><h3 id="View-getHTML">getHTML<span class="caption">Override this function in your views to get full control over what goes into view.$el during `render`.</span></h3><p>Giraffe implements its own <code>render</code> function which calls <code>getHTML</code> to get the HTML string to put inside <code>view.$el</code>. Your views can either define a <code>template</code>, which uses <strong>Underscore</strong> templates by default, or override <code>getHTML</code>, returning a string of HTML from your favorite templating engine.</p><h3 id="View-serialize">serialize<span class="caption">Override this function to pass custom data to a view's `templateFunction`.</span></h3><p>Gets the data passed to the <code>templateFunction</code>. By default, returns an object with direct references to the view's <code>model</code> and <code>collection</code>.</p><h3 id="View-detach">detach<span class="caption">view.detach([preserve])</span></h3><p>Detaches the view from the DOM. If <code>options.disposeOnDetach</code> is true, which is the default, <code>dispose</code> will be called on the view and its <code>children</code> unless <code>preserve</code> is true. <code>preserve</code> defaults to false.</p><h3 id="View-detachChildren">detachChildren<span class="caption">view.detachChildren([preserve])</span></h3><p>Calls <code>detach</code> on each object in <code>children</code>, passing the <code>preserve</code> parameter through.</p><h3 id="View-addChild">addChild<span class="caption">view.addChild(child)</span></h3><p>Adds <code>child</code> to this view's <code>children</code> and assigns this view as <code>child.parent</code>. If <code>child</code> implements <code>dispose</code>, it will be called when the view is disposed. If <code>child</code> implements <code>detach</code>, it will be called before the view renders.</p><h3 id="View-addChildren">addChildren<span class="caption">view.addChildren(children)</span></h3><p>Calls <code>addChild</code> on the given array of objects.</p><h3 id="View-removeChild">removeChild<span class="caption">view.removeChild(child, [preserve])</span></h3><p>Removes an object from this view's <code>children</code>. If <code>preserve</code> is <code>false</code>, the default, Giraffe will attempt to call <code>dispose</code> on the child. If <code>preserve</code> is true, Giraffe will attempt to call <code>detach</code> on the child.</p><h3 id="View-removeChildren">removeChildren<span class="caption">view.removeChildren([preserve])</span></h3><p>Calls <code>removeChild</code> on all <code>children</code>, passing <code>preserve</code> through.</p><h3 id="View-setParent">setParent<span class="caption">view.setParent([parent])</span></h3><p>Sets a new parent for a view. <code>parent</code> can be <code>null</code> or <code>undefined</code> to remove the current parent.</p><h3 id="View-isAttached">isAttached<span class="caption">view.isAttached([el])</span></h3><p>If <code>el</code> is <code>null</code> or <code>undefined</code>, tests if the view is somewhere on the DOM by calling <code>$(document).find(this.$el)</code>. If <code>el</code> is defined, tests if <code>el</code> is the immediate parent of the view.</p><h3 id="View-ui">ui<span class="caption">view.ui</span></h3><p>The optional <code>ui</code> object maps names to selectors, e.g. <code>{$someName: '#some-selector'}</code>. If a view defines <code>ui</code>, the jQuery objects it names will be cached and updated every <code>render</code>. For example, declaring <code>this.ui = {$button: '#button'}</code> in a view makes <code>this.$button</code> always available once <code>render</code> has been called.</p><h3 id="View-invoke">invoke<span class="caption">view.invoke(method, [args...])</span></h3><p>Calls <code>method</code> on the view, or if not found, up the view hierarchy, passing <code>args</code> through. Used by Giraffe to call the methods defined for the events bound in <code>setDocumentEvents</code>.</p><h3 id="View-appEvents">appEvents<span class="caption">view.appEvents</span></h3><p>Define <code>appEvents</code> on any Giraffe object to listen to events on <code>this.app</code>, which is either the option passed in <code>{app: myApp}</code> or the first instance of <strong>Giraffe.App</strong> created on the page, which is globally assigned to <code>Giraffe.app</code>. Any object with a reference to an app can <code>trigger</code> arbitrary <code>appEvents</code>, and any object with a reference to a router can <code>cause</code> an app event and navigate to its corresponding route.</p><h3 id="View-dispose">dispose<span class="caption">view.dispose()</span></h3><p>Destroys a view, unbinding its events and freeing its resources. Calls the <code>remove</code> method defined by <strong>Backbone.View</strong> and calls <code>dispose</code> on all <code>children</code>.</p><h3 id="View-detachByEl">detachByEl<span class="caption">Giraffe.View.detachByEl(el, [preserve])</span></h3><p>Detaches the top-level views inside <code>el</code>, which can be a selector, element, jQuery object, or <strong>Giraffe.View</strong>. Used internally by Giraffe to remove views that would otherwise be clobbered when the <code>method</code> option <code>'html'</code> is used to attach a view. Uses the <code>data-view-cid</code> attribute to correlate DOM nodes to view instances.</p><h3 id="View-getClosestView">getClosestView<span class="caption">Giraffe.View.getClosestView(el)</span></h3><p>Gets the closest parent view of <code>el</code>, which can be a selector, element, jQuery object, or <strong>Giraffe.View</strong>. Uses the <code>data-view-cid</code> attribute to correlate DOM nodes to view instances.</p><h3 id="View-getByCid">getByCid<span class="caption">Giraffe.View.getByCid(cid)</span></h3><p>Looks up a view from the cache by <code>cid</code>, returning undefined if not found.</p><h3 id="View-removeDocumentEvents">removeDocumentEvents<span class="caption">Giraffe.View.removeDocumentEvents()</span></h3><p>Using the form <code>data-gf-event</code>, DOM elements can be configured to call view methods on DOM events. By default, Giraffe only binds the most common events to keep things lean. To configure your own set of events, use Giraffe.View.setDocumentEvents to reset the bindings to the events of your choosing. For example, if you want only the click and mousedown events, call Giraffe.View.setDocumentEvents(['click', 'mousedown']). If you wish to remove Giraffe's document event features completely, call <code>removeDocumentEvents</code>. It is not necessary to call this method before setting new ones. Setting document events removes the current ones.</p><h3 id="View-setDocumentEvents">setDocumentEvents<span class="caption">Giraffe.View.setDocumentEvents(events)</span></h3><p>Giraffe provides a convenient high-performance way to declare view method calls in your HTML markup. Using the form <code>data-gf-eventName='methodName'</code>, when a bound DOM event is triggered, Giraffe looks for the defined method on the element's view. For example, putting <code>data-gf-click='submitForm'</code> on a button calls the method <code>submitForm</code> on its view on <code>'click'</code>. If the view does not define the method, Giraffe searches up the view hierarchy until it finds it or runs out of views. By default, only the <code>click</code> and <code>change</code> events are bound by Giraffe, but <code>setDocumentEvents</code> allows you to set a custom list of events, first unbinding the existing ones and then setting the ones you give it, if any.</p>

<pre><code>Giraffe.View.setDocumentEvents(['click', 'change', 'keydown']);

Giraffe.View.setDocumentEvents('click change keydown keyup');
</code></pre><h3 id="View-setTemplateStrategy">setTemplateStrategy<span class="caption">Giraffe.View.setTemplateStrategy(strategy)</span></h3><p>Giraffe provides common strategies for templating.</p></section><section><h2 id="App">App<span class="caption">new Giraffe.App([options])</span></h2><p><strong>Giraffe.App</strong> is a special <strong>Giraffe.View</strong> that provides encapsulation for an entire application. Like all Giraffe views, the app has lifecycle management for all <code>children</code>, so calling <code>dispose</code> on an app will destroy all views, models, collections, and routers that have been added as <code>children</code> of the app or its descendents. The first <strong>Giraffe.App</strong> created on a page is available globally at <code>Giraffe.app</code>, and by default all Giraffe objects reference this app as <code>this.app</code> unless they're passed a different app in <code>options.app</code>. This app reference is used to bind <code>appEvents</code>, a hash that all Giraffe objects can implement which uses the app as an event aggregator for communication and routing. The app also provides synchronous and asynchronous initializers with <code>addInitializer</code> and <code>start</code>.</p><h3 id="App-addInitializer">addInitializer<span class="caption">app.addInitializer(fn)</span></h3><p>Queues up the provided function to be run on <code>start</code>. The functions you provide are called with the same <code>options</code> object passed to <code>start</code>. If the provided function has two arguments, the options and a callback, the app's initialization will wait until you call the callback. If the callback is called with a truthy first argument, an error will be logged and initialization will halt. If the app has already started when you call <code>addInitializer</code>, the function is called immediately.</p>

<pre><code>app.addInitializer(function(options, cb) {
    doAsyncStuff(cb);
});
</code></pre><h3 id="App-start">start<span class="caption">app.start([options])</span></h3><p>Starts the app by executing each initializer in the order it was added, passing <code>options</code> through the initializer queue. Triggers the <code>appEvents</code> <code>'app:initializing'</code> and <code>'app:initialized'</code>.</p></section><section><h2 id="Router">Router<span class="caption">new Giraffe.Router([options])</span></h2><p>The <strong>Giraffe.Router</strong> integrates with a <strong>Giraffe.App</strong> to decouple your router and route handlers and to provide programmatic encapsulation for your routes. A route can be handled by any Giraffe object by subscribing to the corresponding app event defined in <code>triggers</code>. The <code>cause</code> method navigates to a route and triggers the corresponding app event, and you can ask the router if a given app event is currently caused via <code>isCaused</code>. Additionally, rather than building anchor links and window locations manually, you can build routes from app events and optional parameters with <code>getRoute</code>.</p><h3 id="Router-triggers">triggers<span class="caption">router.triggers</span></h3><p>The <code>triggers</code> hash is similar to the <code>routes</code> hash of <strong>Backbone.Router</strong>, but instead of <code>route: method</code> the <strong>Giraffe.Router</strong> expects <code>route: appEvent</code>, e.g. <code>'someUrl/:andItsParams': 'some:appEvent'</code>. See the <strong>Giraffe.App</strong> and its <code>appEvents</code> for more.</p>

<pre><code>var router = new Giraffe.Router({triggers: {'route': 'appEvent'}});

var MyRouter = Giraffe.Router.extend({triggers: {'route': 'appEvent'}});
var myRouter = new MyRouter();
</code></pre><h3 id="Router-reload">reload<span class="caption">router.reload([url])</span></h3><p>Performs a page refresh. If <code>url</code> is defined, the router first silently navigates to it before refeshing.</p><h3 id="Router-cause">cause<span class="caption">router.cause(appEvent, [any])</span></h3><p>Triggers an app event with optional arguments. If <code>this.triggers</code> has a matching route, <code>Backbone.history</code> navigates to it.</p><h3 id="Router-isCaused">isCaused<span class="caption">router.isCaused(appEvent, [any])</span></h3><p>Returns true if the current <code>window.location</code> matches the route that the given app event and optional arguments map to.</p><h3 id="Router-getRoute">getRoute<span class="caption">router.getRoute(appEvent, [any])</span></h3><p>Converts an app event and optional arguments into a url mapped in <code>this.triggers</code>. Useful if you want to programmatically encapsulate your routes, so you don't need to manually build anchor links and window locations to navigate to.</p><h3 id="Router-appEvents">appEvents<span class="caption">router.appEvents</span></h3><p>Define <code>appEvents</code> on any Giraffe object to listen to events on <code>this.app</code>, which is either the option passed in <code>{app: myApp}</code> or the first instance of <strong>Giraffe.App</strong> created on the page, which is globally assigned to <code>Giraffe.app</code>. Any object with a reference to an app can <code>trigger</code> arbitrary <code>appEvents</code>, and any object with a reference to a router can <code>cause</code> an app event and navigate to its corresponding route.</p><h3 id="Router-dispose">dispose<span class="caption">router.dispose()</span></h3><p>Removes registered callbacks.</p></section><section><h2 id="Model">Model<span class="caption">new Giraffe.Model([attributes], [options])</span></h2><p><strong>Giraffe.Model</strong> and <strong>Giraffe.Collection</strong> are thin wrappers that add lifecycle management and <code>appEvents</code> support. To add lifecycle management to an arbitrary object, simply give it a <code>dispose</code> method and add it to a view via <code>addChild</code>. The function <code>Giraffe.dispose</code> can be used to perform some useful disposal work. The helper function <code>Giraffe.bindEventMap</code> adds <code>appEvents</code> bindings for any object, and Backbone's <code>stopListening</code> will unbind them.</p><h3 id="Model-appEvents">appEvents<span class="caption">model.appEvents</span></h3><p>Define <code>appEvents</code> on any Giraffe object to listen to events on <code>this.app</code>, which is either the option passed in <code>{app: myApp}</code> or the first instance of <strong>Giraffe.App</strong> created on the page, which is globally assigned to <code>Giraffe.app</code>. Any object with a reference to an app can <code>trigger</code> arbitrary <code>appEvents</code>, and any object with a reference to a router can <code>cause</code> an app event and navigate to its corresponding route.</p><h3 id="Model-dispose">dispose<span class="caption">model.dispose()</span></h3><p>Removes event listeners and removes this model from its collection.</p></section><section><h2 id="Collection">Collection<span class="caption">new Giraffe.Collection([models], [options])</span></h2><p><strong>Giraffe.Model</strong> and <strong>Giraffe.Collection</strong> are thin wrappers that add lifecycle management and <code>appEvents</code> support. To add lifecycle management to an arbitrary object, simply give it a <code>dispose</code> method and add it to a view via <code>addChild</code>. The function <code>Giraffe.dispose</code> can be used to perform some useful disposal work. The helper function <code>Giraffe.bindEventMap</code> adds <code>appEvents</code> bindings for any object, and Backbone's <code>stopListening</code> will unbind them.</p><h3 id="Collection-appEvents">appEvents<span class="caption">collection.appEvents</span></h3><p>Define <code>appEvents</code> on any Giraffe object to listen to events on <code>this.app</code>, which is either the option passed in <code>{app: myApp}</code> or the first instance of <strong>Giraffe.App</strong> created on the page, which is globally assigned to <code>Giraffe.app</code>. Any object with a reference to an app can <code>trigger</code> arbitrary <code>appEvents</code>, and any object with a reference to a router can <code>cause</code> an app event and navigate to its corresponding route.</p><h3 id="Collection-dispose">dispose<span class="caption">collection.dispose()</span></h3><p>Removes event listeners and disposes of all models, which removes them from the collection.</p></section><section><h2 id="dispose">dispose<span class="caption">Giraffe.dispose(obj, [fn], [args...])</span></h2><p>Disposes of a object. Calls Backbone's <code>obj.stopListening()</code> and sets <code>obj.app</code> to null. Also triggers <code>'disposing'</code> and <code>'disposed'</code> events on <code>obj</code> before and after the disposal. Takes an optional <code>fn</code> argument to do additional work, and optional <code>args</code> that are passed through to the events and <code>fn</code>.</p></section><section><h2 id="bindEvent">bindEvent<span class="caption">Giraffe.bindEvent(targetObj, eventName, cb, contextObj)</span></h2><p>Makes <code>contextObj</code> listen for <code>eventName</code> on <code>targetObj</code> with the callback <code>cb</code>.</p></section><section><h2 id="unbindEvent">unbindEvent<span class="caption">Giraffe.unbindEvent(targetObj, eventName, cb, contextObj)</span></h2><p>The <code>stopListening</code> equivalent of <code>bindEvent</code>.</p></section><section><h2 id="bindEventMap">bindEventMap<span class="caption">Giraffe.bindEventMap(targetObj, eventMap, cb, contextObj)</span></h2><p>Binds an event map of the form <code>{eventName: methodName}</code> to <code>targetObj</code> with <code>contextObj</code> being the listening object.</p></section><section><h2 id="unbindEventMap">unbindEventMap<span class="caption">Giraffe.unbindEventMap(targetObj, eventMap, cb, contextObj)</span></h2><p>The <code>stopListening</code> equivalent of <code>bindEventMap</code>.</p></section></div>
      </article>
    </div>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>
    <script src="_assets/tutdown.js"></script>
</body>
</html>

